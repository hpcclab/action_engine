Id,name,input_parameters_with_datatype,input_description,output_data_type,output description,description,method,url,summary,source_code
1,tti_Animation_Art,prompt: string,The input parameter for this API is a user prompt in string data type.,binary_image_file,Generated animation image as a binary_image_file,This API takes a user prompt and generates an image in animation style using a pre-trained model. The user needs to provide a prompt in string format and the API will return the generated animation image as a response in the form of a FileResponse.,POST,,"The 'tti_Animation_Art' API utilizes a POST method to transform user prompts into captivating animation images. By inputting a user prompt in string format, individuals can provide descriptive content or themes for the image generation process. The API employs a sophisticated pre-trained model to convert these textual inputs into vibrant animation-style images. Upon processing the input prompt, the API seamlessly delivers the resulting artwork as a binary_image_file, encapsulating the dynamically generated animation. This API empowers users to effortlessly merge textual creativity with visual artistry, enabling the creation of detailed animated images for various digital media applications and creative projects.","from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse

from PIL import Image
from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
import torch
from pydantic import BaseModel
from pathlib import Path

app = FastAPI()

def load_model():
    model_id = 'dreamlike-art/dreamlike-anime-1.0'
    pipe = StableDiffusionPipeline.from_pretrained(model_id, torch_dtype=torch.float16)
    pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    pipe = pipe.to('cuda')
    return pipe

def process_data(prompt, pipe):
    response = pipe(prompt).images[0]
    return response

@app.post(""/generate_anime_image/"")
async def generate_image(prompt:str):
    try:

        # Load the model (replace load_model() with your actual model loading logic)
        pipe = load_model()

        # Prompt Creation
        prompt = ""Anime-style picture: "" + prompt

        # Process the data (replace process_data() with your actual data processing logic)
        response = process_data(prompt, pipe)

        ## Save the image
        response.save('generated_img.png')

        image_path = Path('generated_img.png')
        
        if not image_path.is_file():
            return {""error"": ""Image not found on the server""}

        return FileResponse(image_path)
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
2,tti_Charcoal_Art,prompt: string,The input parameter for this API is a user prompt in string data type.,binary_image_file,An image in a specific charcoal art style format,This API processes an input user prompt to generate an image in charcoal art style. It takes a text prompt from the user converts it into a charcoal art style image and returns the resulting image. The input parameter is a string containing the user prompt and the output is an image in the charcoal art style.,POST,,"The 'tti_Charcoal_Art' API utilizes a POST method to transform textual prompts into visually engaging charcoal art style images. Users supply a prompt in string format, specifying the content or theme for the artwork they desire. This input prompt is then processed by the API to generate a unique image in the distinctive charcoal art style. The output of the API is delivered as a binary_image_file, presenting the user with a creative representation of their original prompt transformed into a charcoal art format. This API seamlessly merges textual input with artistic expression, providing users with a simple yet powerful tool to create captivating charcoal art imagery.","from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse

from PIL import Image
from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
import torch
from pydantic import BaseModel
from pathlib import Path

app = FastAPI()

def load_model():
    model_id = 'Falah/charcoal-style'
    pipe = StableDiffusionPipeline.from_pretrained(model_id, torch_dtype=torch.float16)
    pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    pipe = pipe.to('cuda')
    return pipe

def process_data(prompt, pipe):
    response = pipe(prompt).images[0]
    return response

@app.post(""/generate_charcoal_image/"")
async def generate_image(prompt:str):
    try:

        # Load the model (replace load_model() with your actual model loading logic)
        pipe = load_model()

        # Prompt Creation
        prompt = ""Charcoal-style picture: "" + prompt

        # Process the data (replace process_data() with your actual data processing logic)
        response = process_data(prompt, pipe)

        ## Save the image
        response.save('generated_img.png')

        image_path = Path('generated_img.png')
        if not image_path.is_file():
            return {""error"": ""Image not found on the server""}

        return FileResponse(image_path)
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
3,tti_Digital_Art,prompt: string,The input parameter for this API is a user prompt in string data type.,binary_image_file,Generated digital art image in file format,This API takes a user prompt as input and generates an image in digital art style using a pre-trained model for diffusion art generation. The user prompt is provided as a string and the output is a digital art image saved in a file format.,POST,,"The 'tti_Digital_Art' API utilizes a POST method to transform user prompts into visually striking digital art images through a pre-trained model specialized in diffusion art generation. Users supply a prompt in string format, describing the desired content or concept for the artwork. The API processes this input to create a unique digital art piece, which is then delivered to the user as a binary_image_file, encapsulating the generated masterpiece in a file format. This API seamlessly merges textual inspiration with artistic interpretation, empowering users to effortlessly convert their ideas into captivating digital artworks, enhancing creative projects and visual storytelling.","from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse

from PIL import Image
from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
import torch
from pydantic import BaseModel
from pathlib import Path

app = FastAPI()

def load_model():
    model_id = ""DGSpitzer/DGSpitzer-Art-Diffusion""
    pipe = StableDiffusionPipeline.from_pretrained(model_id, torch_dtype=torch.float16)
    pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    pipe = pipe.to('cuda')
    return pipe

def process_data(prompt, pipe):
    response = pipe(prompt).images[0]
    return response

@app.post(""/generate_digital_image/"")
async def generate_image(prompt:str):
    try:

        # Load the model (replace load_model() with your actual model loading logic)
        pipe = load_model()

        # Prompt Creation
        prompt = ""Digital-style picture: "" + prompt

        # Process the data (replace process_data() with your actual data processing logic)
        response = process_data(prompt, pipe)

        ## Save the image
        response.save('generated_img.png')

        image_path = Path('generated_img.png')
        if not image_path.is_file():
            return {""error"": ""Image not found on the server""}

        return FileResponse(image_path)
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
4,tti_Futuristic_Art,prompt: string,The input parameter for this API is a user prompt in string data type.,binary_image_file,Generated image in Futuristic art style (image file),This API takes a user prompt as input and generates an image in Futuristic art style using a pre-trained model. The input is a user prompt in the form of a string and the output is the generated image in the Futuristic art style in the form of an image file.,POST,,"The 'tti_Futuristic_Art' API utilizes a POST method to transform user prompts into visually captivating images inspired by Futuristic art. By inputting a textual prompt in string format, users can trigger the API to process the information through a pre-trained model, resulting in the creation of an artwork embodying Futuristic art aesthetics. The output of the API is a binary_image_file containing the generated image, allowing users to seamlessly convert their ideas into Futuristic art-themed visual representations, ideal for creative projects and digital artistry.","from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse

from PIL import Image
from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
import torch
from pydantic import BaseModel
from pathlib import Path

app = FastAPI()

def load_model():
    model_id = 'nitrosocke/Future-Diffusion'
    pipe = StableDiffusionPipeline.from_pretrained(model_id, torch_dtype=torch.float16)
    pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    pipe = pipe.to('cuda')
    return pipe

def process_data(prompt, pipe):
    response = pipe(prompt).images[0]
    return response

@app.post(""/generate_futuristic_image/"")
async def generate_image(prompt:str):
    try:

        # Load the model (replace load_model() with your actual model loading logic)
        pipe = load_model()

        # Prompt Creation
        prompt = ""Futuristic-style picture: "" + prompt

        # Process the data (replace process_data() with your actual data processing logic)
        response = process_data(prompt, pipe)

        ## Save the image
        response.save('generated_img.png')

        image_path = Path('generated_img.png')
        if not image_path.is_file():
            return {""error"": ""Image not found on the server""}

        return FileResponse(image_path)
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
5,tti_Graffiti_Art,prompt: string,The input parameter for this API is a user prompt in string data type.,binary_image_file,An image in graffiti art style,This API takes a user prompt as input and generates an image in graffiti art style using a pre-trained model. The input is a string prompt provided by the user and the output is an image in graffiti art style,POST,,"The 'tti_Graffiti_Art' API utilizes a POST method to transform user-provided textual prompts into visually appealing graffiti-style images. By accepting a string input prompt from the user, this API leverages a pre-trained model to create unique artwork in the form of graffiti art. The output of this process is delivered as a binary_image_file, encapsulating the generated graffiti art image. This API serves as a creative tool, allowing users to seamlessly translate their ideas and prompts into vibrant graffiti-style visual representations, catering to artistic expression and design needs.","from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse

from PIL import Image
from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
import torch
from pydantic import BaseModel
from pathlib import Path

app = FastAPI()

def load_model():
    model_id = 'bakebrain/bergraffi-berlin-graffiti'
    pipe = StableDiffusionPipeline.from_pretrained(model_id, torch_dtype=torch.float16)
    pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    pipe = pipe.to('cuda')
    return pipe

def process_data(prompt, pipe):
    response = pipe(prompt).images[0]
    return response

@app.post(""/generate_grafiti_image/"")
async def generate_image(prompt:str):
    try:

        # Load the model (replace load_model() with your actual model loading logic)
        pipe = load_model()

        # Prompt Creation
        prompt = ""Grafiti-style picture: "" + prompt

        # Process the data (replace process_data() with your actual data processing logic)
        response = process_data(prompt, pipe)

        ## Save the image
        response.save('generated_img.png')

        image_path = Path('generated_img.png')
        if not image_path.is_file():
            return {""error"": ""Image not found on the server""}

        return FileResponse(image_path)
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
6,tti_Mosaic_Art,prompt: string,The input parameter for this API is a user prompt in string data type.,binary_image_file,Generated image in mosaic art style,This API takes a user prompt and generates an image in mosaic art style.,POST,,"The 'tti_Mosaic_Art' API utilizes a POST method to transform user-provided prompts into captivating mosaic art style images. By inputting a prompt in string format, users can trigger the generation of a visually striking mosaic art piece. The API then processes this input, leveraging intricate algorithms to craft a unique image that embodies the essence of mosaic aesthetics. The output is presented as a binary_image_file, encapsulating the mosaic artwork created based on the user's initial prompt. This API serves as a creative tool for generating artistic mosaic compositions, offering users a seamless pathway to infuse their ideas with visually stunning mosaic designs.","from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse

from PIL import Image
from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
import torch
from pydantic import BaseModel
from pathlib import Path

app = FastAPI()

def load_model():
    model_id = 'Guizmus/MosaicArt'
    pipe = StableDiffusionPipeline.from_pretrained(model_id, torch_dtype=torch.float16)
    pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    pipe = pipe.to('cuda')
    return pipe

def process_data(prompt, pipe):
    response = pipe(prompt).images[0]
    return response

@app.post(""/generate_mosaic_image/"")
async def generate_image(prompt:str):
    try:

        # Load the model (replace load_model() with your actual model loading logic)
        pipe = load_model()

        # Prompt Creation
        prompt = ""Mosiac-style picture: "" + prompt

        # Process the data (replace process_data() with your actual data processing logic)
        response = process_data(prompt, pipe)

        ## Save the image
        response.save('generated_img.png')

        image_path = Path('generated_img.png')
        if not image_path.is_file():
            return {""error"": ""Image not found on the server""}

        return FileResponse(image_path)
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
7,tti_Painting_Art,prompt: string,The input parameter for this API is a user prompt in string data type.,binary_image_file,Generated image in painting art style (file),This API takes a user prompt and generates an image in a painting art style. It uses a pre-trained model to process the prompt and produce the painting image as output. The input parameter is the prompt provided by the user as a string and the output is the generated image in painting art style saved as a file.,POST,,"The 'tti_Painting_Art' API facilitates the conversion of user prompts into artwork resembling a painting via a POST method. By receiving a prompt in string format as an input, users can describe their desired artistic content or theme. This API employs a sophisticated pre-trained model to transform the input prompt into a unique painting art style image, which is subsequently returned as a binary_image_file. Users can leverage this API to seamlessly translate textual descriptions into visually captivating painting-style images, enhancing their creative projects or digital media endeavors.","from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse

from PIL import Image
from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
import torch
from pydantic import BaseModel
from pathlib import Path

app = FastAPI()

def load_model():
    model_id = ""dallinmackay/Van-Gogh-diffusion""
    pipe = StableDiffusionPipeline.from_pretrained(model_id, torch_dtype=torch.float16)
    pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    pipe = pipe.to('cuda')
    return pipe

def process_data(prompt, pipe):
    response = pipe(prompt).images[0]
    return response

@app.post(""/generate_painting_image/"")
async def generate_image(prompt:str):
    try:

        # Load the model (replace load_model() with your actual model loading logic)
        pipe = load_model()

        # Prompt Creation
        prompt = ""Lvngvncnt-style picture: "" + prompt

        # Process the data (replace process_data() with your actual data processing logic)
        response = process_data(prompt, pipe)

        ## Save the image
        response.save('generated_img.png')

        image_path = Path('generated_img.png')
        if not image_path.is_file():
            return {""error"": ""Image not found on the server""}

        return FileResponse(image_path)
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
8,tti_Pastel_Art,prompt: string,The input parameter for this API is a user prompt in string data type.,binary_image_file,Generated image in png file format,This API takes a user prompt and generates an image in pastel art style. It loads a pre-trained model for pastel art generation and processes the user prompt to create the image. The generated image is returned in the form of a PNG file.,POST,,"The 'tti_Pastel_Art' API allows users to create pastel art images through a POST method. By providing a prompt in string format, users can guide the generation of a unique pastel art piece using a pre-trained model specialized for this art style. The output of this API is delivered as a binary_image_file, presenting the final artwork in PNG file format. This API facilitates the seamless translation of text prompts into visually appealing pastel art, offering a creative tool for digital artists and enthusiasts to explore and express their artistic visions in a distinctive, soft-palette aesthetic.","from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse

from PIL import Image
from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
import torch
from pydantic import BaseModel
from pathlib import Path

app = FastAPI()

def load_model():
    model_id = 'JamesFlare/pastel-mix'
    pipe = StableDiffusionPipeline.from_pretrained(model_id, torch_dtype=torch.float16)
    pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    pipe = pipe.to('cuda')
    return pipe

def process_data(prompt, pipe):
    response = pipe(prompt).images[0]
    return response

@app.post(""/generate_pastel_image/"")
async def generate_image(prompt:str):
    try:

        # Load the model (replace load_model() with your actual model loading logic)
        pipe = load_model()

        # Prompt Creation
        prompt = ""Pastel-style picture: "" + prompt

        # Process the data (replace process_data() with your actual data processing logic)
        response = process_data(prompt, pipe)

        ## Save the image
        response.save('generated_img.png')

        image_path = Path('generated_img.png')
        if not image_path.is_file():
            return {""error"": ""Image not found on the server""}

        return FileResponse(image_path)
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
9,tti_Sketching_Art,prompt: string,The input parameter for this API is a user prompt in string data type.,binary_image_file,Generated sketching art style image in PNG format,This API takes a user prompt as input and generates an image in sketching art style using the LoRA model and VAE component. The input prompt is combined with predefined negative prompts to guide the image generation process. The output is a high-quality sketching art style image saved in PNG format.,POST,,"The 'tti_Sketching_Art' API operates through a POST method to transform user prompts into artistic sketching images with the aid of the LoRA model and VAE component. Users provide a textual prompt in string format, which is then harmonized with pre-defined negative prompts to steer the generation of the artwork. The API proficiently processes this input, resulting in the creation of a visually striking sketching art style image. The final output is delivered in the form of a binary_image_file, encapsulating the generated art piece in PNG format. This API seamlessly merges user creativity with advanced AI techniques, empowering users to effortlessly convert simple prompts into sophisticated sketching art, enabling diverse applications in digital artistry and creative projects.","from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse

from pydantic import BaseModel
from pathlib import Path


import torch
from diffusers import (
    StableDiffusionXLPipeline, 
    EulerAncestralDiscreteScheduler,
    AutoencoderKL
)
app = FastAPI()

@app.post(""/generate_sketching_image/"")
async def generate_image(prompt:str):
    try:

        # Initialize LoRA model and weights
        lora_model_id = ""Linaqruf/sketch-style-xl-lora""
        lora_filename = ""sketch-style-xl.safetensors""

        # Load VAE component
        vae = AutoencoderKL.from_pretrained(
            ""madebyollin/sdxl-vae-fp16-fix"", 
            torch_dtype=torch.float16
        )

        # Configure the pipeline
        pipe = StableDiffusionXLPipeline.from_pretrained(
            ""Linaqruf/animagine-xl-2.0"", 
            vae=vae,
            torch_dtype=torch.float16, 
            use_safetensors=True, 
            variant=""fp16""
        )
        pipe.scheduler = EulerAncestralDiscreteScheduler.from_config(pipe.scheduler.config)
        pipe.to('cuda')

        # Load and fuse LoRA weights
        pipe.load_lora_weights(lora_model_id, weight_name=lora_filename)
        pipe.fuse_lora(lora_scale=0.6)

        # Define prompts and generate image
        prompt = ""Monochrome, Greyscale Sketch-style picture: "" + prompt
        

        negative_prompt = ""lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry""

        image = pipe(
            prompt, 
            negative_prompt=negative_prompt, 
            width=1024,
            height=1024,
            guidance_scale=12,
            num_inference_steps=50
        ).images[0]

        # Unfuse LoRA before saving the image
        pipe.unfuse_lora()
        image.save(""generated_img.png"")

        image_path = Path('generated_img.png')
        if not image_path.is_file():
            return {""error"": ""Image not found on the server""}
        return FileResponse(image_path)
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
10,tti_Ukiyo-e_Art,prompt: string,The input parameter for this API is a user prompt in string data type.,binary_image_file,The output of this API is an image generated in ukiyo-e art style.,This API takes a user prompt as input and generates an image in the traditional Japanese ukiyo-e art style. The input prompt is concatenated with 'Japanese Ukiyo e-style picture:' before processing. The generated image is then saved as a PNG file and returned as a response.,POST,,"The 'tti_Ukiyo-e_Art' API is a resourceful tool that converts user prompts into visually captivating images resembling the traditional Japanese ukiyo-e art style using a POST method. Users submit a prompt in string format, which is enriched by appending 'Japanese Ukiyo e-style picture:' to guide the image creation process. Through intricate processing, the API yields an image brimming with ukiyo-e aesthetics and nuances, ultimately delivering the output as a PNG binary_image_file. This API seamlessly merges modern inputs with historical artistic styles, offering users a gateway to explore and integrate traditional Japanese artistry into contemporary digital creations.","from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse

from PIL import Image
from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
import torch
from pydantic import BaseModel
from pathlib import Path

app = FastAPI()

def load_model():
    model_id = 'salmonhumorous/ukeiyo-style-diffusion'
    pipe = StableDiffusionPipeline.from_pretrained(model_id, torch_dtype=torch.float16)
    pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    pipe = pipe.to('cuda')
    return pipe

def process_data(prompt, pipe):
    response = pipe(prompt).images[0]
    return response

@app.post(""/generate_ukiyoe_image/"")
async def generate_image(prompt:str):
    try:

        # Load the model (replace load_model() with your actual model loading logic)
        pipe = load_model()

        # Prompt Creation
        prompt = ""Japanese Ukiyo e-style picture: "" + prompt

        # Process the data (replace process_data() with your actual data processing logic)
        response = process_data(prompt, pipe)

        ## Save the image
        response.save('generated_img.png')

        image_path = Path('generated_img.png')
        if not image_path.is_file():
            return {""error"": ""Image not found on the server""}

        return FileResponse(image_path)
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
11,image_to_pdf_conversion,file: binary_image_file,An image file in supported format (.JPEG .PNG .GIF .BMP .TIFF .PBM .PGM .PPM),binary_image_file,A PDF file,This API allows users to convert an image file to a PDF document. Users need to upload an image file with one of the supported formats and the API will process the image and generate a corresponding PDF file as output.,POST,,"The 'image_to_pdf_conversion' API offers a convenient solution for converting image files to PDF documents through a POST method. Users can upload an image file in formats such as JPEG, PNG, GIF, BMP, TIFF, PBM, PGM, or PPM as the input parameter. Once the image is provided, the API seamlessly processes it and produces a PDF file as the output, allowing for efficient transformation of visual content into a portable and universally accessible format. This functionality streamlines the conversion process, enabling users to effortlessly convert diverse image types into PDF documents to facilitate sharing, printing, or archiving purposes.","from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.responses import FileResponse
from pathlib import Path
from PIL import Image
import img2pdf

app = FastAPI()

# Define the supported image extensions
supported_extensions = ["".JPEG"", "".PNG"", "".GIF"", "".BMP"", "".TIFF"", "".PBM"", "".PGM"", "".PPM""]


def check_file_extension(file_path):
    file_extension = file_path.suffix.upper()
    if file_extension not in supported_extensions:
        return False
    return True


@app.post(""/convert_to_pdf/"")
async def image_to_pdf(file: UploadFile):
    try:
        file_path = Path(file.filename)
        file_name = file_path.stem
        
        
        # # File format support check
        if not check_file_extension(file_path):
            return {""error"": ""Unsupported format""}

        # Read the contents of the uploaded file
        contents = await file.read()
        
        pdf_bytes = img2pdf.convert(contents)
        
        pdf_file_path = f'{file_name}.pdf'

        with open(pdf_file_path, 'wb') as pdf_file:
            pdf_file.write(pdf_bytes)

        # Return the PDF file
        return FileResponse(pdf_file_path, media_type=""application/pdf"", filename=""output.pdf"")
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
12,Image_Resizing,"width: int, height: int, file: binary_image_file",The input for this API is an image file uploaded by the user.,binary_image_file,The output of this API is a resized version of the input image in PDF format.,This API takes an image file as input uploaded by the user and resizes it to the specified width and height. It then converts the resized image into a PDF file and returns the PDF file as output. The main objective of this API is to allow users to resize images and convert them into PDF format.,POST,,"The 'Image_Resizing' API employs a POST method to resize user-uploaded image files by the specified width and height dimensions. Users provide image files in binary form as input to the API, where the resizing process is carried out. Upon completion, the resized image is transformed into a PDF file, serving as the output in binary_image_file format. This API streamlines the task of image resizing and conversion to PDF, facilitating efficient handling of visual content for users seeking to adjust image dimensions and format for various purposes.","# FastAPI
from fastapi import FastAPI, HTTPException, File, UploadFile
from fastapi.responses import FileResponse
from PIL import Image
import io
import os

app = FastAPI()

@app.post('/resize_image/')
async def resize_image(width: int, height: int, file: UploadFile):
    try:
        # Read the uploaded file contents
        contents = await file.read()

        image = Image.open(io.BytesIO(contents))
        
        # Resize the image
        resized = image.resize((width, height))
        
        # Saving the resized image to a temporary file
        filename = ""resized_image.png""
        resized.save(filename)

        return FileResponse(filename, media_type=""image/png"", filename=""output.png"")
    
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
13,Image_Enhancement,file: binary_image_file,A single image file in supported formats (.bmp .jpeg .png etc.),binary_image_file,Enhanced image file in JPG format,API that takes an image as input enhances its quality by denoising contrast stretching sharpening adjusting brightness and gamma correction then returns the enhanced image in JPG format.,POST,,"The 'Image_Enhancement' API offers a POST method to enhance the quality of images provided by users. Users can upload a single image file in supported formats like .bmp, .jpeg, or .png. The API processes the image by applying denoising, contrast stretching, sharpening, brightness adjustment, and gamma correction techniques to improve its visual quality. Upon completion of enhancements, the API returns the enhanced image in JPG format, allowing users to obtain a higher-quality version of their input image effortlessly.","#FastAPI
from fastapi import FastAPI, HTTPException, File, UploadFile
from fastapi.responses import FileResponse
from pathlib import Path

#Image Enhancement
import cv2
import numpy as np
from PIL import Image

file_path = Path(""./flower.jpg"")

SUPPORTED_FORMATS = [
    "".bmp"", "".dib"",
    "".jpeg"", "".jpg"", "".jpe"",
    "".jp2"",
    "".png"",
    "".webp"",
    "".avif"",
    "".pbm"", "".pgm"", "".ppm"", "".pxm"", "".pnm"",
    "".pfm"",
    "".sr"", "".ras"",
    "".tiff"", "".tif"",
    "".exr"",
    "".hdr"", "".pic""
]


app = FastAPI()

def check_image_extension(img):
    img_path = Path(img.filename)
    return img_path.suffix

@app.post('/image_enhance/')
async def enhance_image(file: UploadFile):
    try:
        #Saving original image
        image_name = file.filename 
        image = Image.open(file.file) 
        image.save(image_name)

        #Loading the image
        img = cv2.imread(image_name)

        #Denoising image
        denoised_image = cv2.fastNlMeansDenoisingColored(img, None, 10, 10, 7, 21)

        #Contrast Stretching(Normalizing)
        contrast_stretched_image = cv2.normalize(denoised_image, None, 255, 0, cv2.NORM_MINMAX, cv2.CV_8UC1)

        # Image Sharpening
        kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]], np.float32)
        sharpened_image = cv2.filter2D(contrast_stretched_image, -1, kernel=kernel)

        #Adjusting Brightness
        brightness_image = cv2.convertScaleAbs(sharpened_image, alpha=1, beta=5)

        # Gamma Correction
        gamma = 1.5
        lookup_table = np.array([((i / 255.0) ** gamma) * 255 for i in np.arange(0, 256)]).astype(""uint8"")
        gamma_corrected_image = cv2.LUT(brightness_image, lookup_table)

        final_name = f'final_{image_name}'
        # Save final image
        cv2.imwrite(final_name, gamma_corrected_image)

        return FileResponse(final_name, media_type='image/jpg', filename=final_name)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))"
14,send_email,"sender_address: string, receiver_address: string, message_text: string, message_subject: string, file: binary_image_file","The input for this API is an sender email address, receiver email address, message, and subject in string, and image file in binary format ",string,Message of success or failure of the email,"The objective of this API endpoint is to send an email message. The endpoint accepts various parameters including the sender's email address, receiver's email address, optional message text, optional message subject, and an optional file attachment.",POST,,"The 'send_email' API provides a POST method for sending email messages seamlessly. Users can input the sender's email address, receiver's email address, message content, subject line in string format, and attach a file in binary format. This versatile API allows for efficient communication by handling the email sending process. Upon completion, the API returns a string message indicating the success or failure status of the email delivery, ensuring effective correspondence and file sharing through a unified endpoint.","#FastAPI
from fastapi import FastAPI, HTTPException, File, UploadFile
from typing import Optional
from pathlib import Path

#Email Sending
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email.mime.audio import MIMEAudio
from email.mime.application import MIMEApplication
import magic

app = FastAPI()


#identify email server and validate email domains
def check_email_support(sender_email, receiver_email):
    if sender_email.endswith(""@gmail.com"") and receiver_email.endswith(""@gmail.com""):
        return 'gmail'
    elif sender_email.endswith(""@outlook.com"") and receiver_email.endswith(""@outlook.com""):
        return 'outlook'
    else:
        return 'unsupported'

def process_picture(contents, message):
    image_file = MIMEImage(contents)
    message.attach(image_file)
    
def process_audio(contents, message, extension):
    audio_file = MIMEAudio(contents, extension)
    message.attach(audio_file)

def process_generic(contents, message):
    application_file = MIMEApplication(contents, 'octet-stream')
    message.attach(application_file)


#send gmail email
def send_gmail(auth_email, auth_password, receiver_email, message):
    # Establishing connection to Gmail's SMTP server
    with smtplib.SMTP('smtp.gmail.com', 587) as server:
        #Encrypting connection using TLS
        server.starttls()
        
        #Accessing user's email accout
        server.login(auth_email, auth_password)
        
        # Sending the email
        try:
            server.sendmail(auth_email, receiver_email, message.as_string())

        except Exception as e:
            return {""Status"": ""Unable to send an email""}

#send outlook email
def send_outlook(auth_email, auth_password, receiver_email, message):
    # Establishing connection to Outlook's SMTP server
    with smtplib.SMTP('smtp-mail.outlook.com', 587) as server:
        #Encrypting connection using TLS
        server.starttls()
        
        #Accessing user's email accout
        server.login(auth_email, auth_password)
        
        # Sending the email
        try:
            server.sendmail(auth_email, receiver_email, message.as_string())

        except Exception as e:
            return {""Status"": ""Unable to send an email""}

@app.post(""/send_email/"")
async def send_email(*, sender: str, receiver: str, msg_text: Optional[""str""] = None, msg_subject: Optional[""str""] = None, file: UploadFile = File(default=None, example=""example.txt"")):
    try:
                
        #check email type
        EMAIL_TYPE = check_email_support(sender, receiver)
        if EMAIL_TYPE == ""unsupported"" :
            return {""Error"": ""Email server is not supported""}

        # Email configuration
        auth_email = sender
        receiver_email = receiver
        auth_password_gmail = ""jwsu wpkv srwg ovpv""
        auth_password_outlook = ""123456789Aa""
        

        # Creating a multipart message
        message = MIMEMultipart()
        message['From'] = auth_email
        message['To'] = receiver_email
        #Setting subject if provided by the user
        message['Subject'] = msg_subject if msg_subject is not None else None

        #Handling text
        if msg_text is not None:
            # Creating MIMEtext object
            plain_text = msg_text
            plain_text_part = MIMEText(plain_text, 'plain')
            # Attaching MIMEtext to MIMEmultipart object
            message.attach(plain_text_part)

        #Handling files
        if file is not None:
            #Saving file data
            file_path = Path(file.filename)
            contents = await file.read()
            
            #Checking file type
            mime_type = magic.Magic(mime=True)
            file_type = mime_type.from_buffer(contents)
            
            if file_type.startswith(""image""):
                process_picture(contents, message)

            elif file_type.startswith(""audio""):
                process_audio(contents, message, file_path.suffix)
                
            else:
                # The rest of files is treated as generic
                process_generic(contents, message)

            
        if EMAIL_TYPE == ""gmail"":
            send_gmail(auth_email, auth_password_gmail, receiver_email, message)
        
        elif EMAIL_TYPE == ""outlook"":
            send_outlook(auth_email, auth_password_outlook, receiver_email, message)

        return {""Status"" : ""Email successfuly sent""}

    except Exception as e: 
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"
15,image_format_converter,"file: binary_image_file, output_format: string",The input for this API is a image and a desired image format name in string ,binary_image_file,A image file with specified user specified output format ,This API takes a image file and name of the desired image format type as input and converts it to the specified image file format. The main objective of this API is to allow users to convert one image format to another.,POST,,"The 'image_format_converter' allows users to upload an image file and convert it to a specified format. It imports necessary modules including FastAPI, File, UploadFile, HTTPException, Form, and others to handle HTTP requests, file uploads, and image processing. The script defines a list of supported image extensions, including JPEG, PNG, GIF, BMP, TIFF, PBM, PGM, PPM, and JPG. A helper function check_file_extension verifies if the file has a supported extension. The main functionality is provided by the /convert_image/ endpoint, which accepts a file upload and an output format. This endpoint reads the uploaded file, checks if the specified output format is supported, opens the uploaded image using the PIL library, saves the image in the desired format, and returns the converted image file as a response. Additionally, the endpoint includes error handling to raise HTTP 500 exceptions if something goes wrong during the process. The overall purpose of the application is to convert uploaded images to different formats specified by the user, supporting various common image file types.","from fastapi import FastAPI, File, UploadFile, HTTPException, Form
from fastapi.responses import FileResponse
from pathlib import Path
from PIL import Image

app = FastAPI()

# Define the supported image extensions
supported_extensions = ["".JPEG"", "".PNG"", "".GIF"", "".BMP"", "".TIFF"", "".PBM"", "".PGM"", "".PPM"", "".JPG""]

img_path = ""/home/cc/AutomaticWorkflowGeneration/FaaS_Searvices/functions/image_format_converter/app/converted.jpg""

def check_file_extension(file_path):
    file_extension = file_path.suffix.upper()
    if file_extension not in supported_extensions:
        return False
    return True


@app.post(""/convert_image/"")
async def convert_image(file: UploadFile, output_format: str = Form(...)):
    try:
        file_path = Path(file.filename)
        file_name = file_path.stem
        output_format = output_format.upper()

        # Validate the output format
        if f"".{output_format}"" not in supported_extensions:
            return {""error"": ""Unsupported output format""}

        # Read the contents of the uploaded file
        contents = await file.read()

        # Open the image using PIL
        input_image = Image.open(file_path)

        # Define the output file path
        output_file_path = f'{file_name}.{output_format.lower()}'

        # Save the image in the desired format
        input_image.save(output_file_path, format=output_format)

        # Return the converted file
        return FileResponse(output_file_path, media_type=f""image/{output_format.lower()}"", filename=output_file_path)
    except Exception as e:
        # Handle exceptions or errors here
        raise HTTPException(status_code=500, detail=str(e))"